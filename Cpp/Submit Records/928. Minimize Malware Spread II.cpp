/********************************************
作者:Alfeim
题目:尽量减少恶意软件的传播Ⅱ
时间消耗:204ms
解题思路:dfs
********************************************/
class Solution {
public:
    unordered_set<int> InitialSet;
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        //找出可行的初始结点
        vector<int> ability(n,0);
        for(auto i : initial) InitialSet.insert(i);

        for(auto i : initial){
           Solve(graph,ability,i);
        }

        //开始遍历
        int res = INT_MAX;
        int MaxCount = 0;
        
        for(auto i : initial){
            if(ability[i] > MaxCount){
                res = i;
                MaxCount = ability[i];
            }else if(ability[i] == MaxCount){
                res = min(res,i);
            }
        }

        return res;
    }

    void Solve(vector<vector<int>>& graph,vector<int> &ability,int node){

        int n = graph.size();

        vector<bool> visited(n,false);
        visited[node] = true;
        int count = 0;

        for(int i = 0 ; i < n ; ++i){
            if(!visited[i] && graph[node][i] == 1 && !InitialSet.count(i)){
                count += Path_Decrease(i,visited,graph);
            }
        }
        
        ability[node] = count;
    }


    int Path_Decrease(int node,vector<bool> &visited,vector<vector<int>> &graph){
        int res = 0;
        int n = graph.size();

        bool flag = true;
        visited[node] = true;
        queue<int> Q;
        Q.push(node);

        while(!Q.empty()){
            res++;
            auto cur = Q.front();
            Q.pop();
            if(InitialSet.count(cur)) flag = false;
            for(int i = 0 ; i < n ; ++i){
                if(!visited[i] && graph[cur][i] == 1){
                    visited[i] = true;
                    Q.push(i);
                }
            }
        }
        return flag ? res : 0;
    }



};
