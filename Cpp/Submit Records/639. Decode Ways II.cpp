/********************************************
作者:Alfeim
题目:解码方法2
时间消耗:72ms
解题思路:动态规划、细节
********************************************/
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<long> dp(n+1,0);
        dp[0] = 1;
        dp[1] = s[0] == '*' ? 9 : s[0] == '0' ? 0 : 1;
        for(int i = 2 ; i <= n ; ++i){
            //如果当前字符是数字
            if(isdigit(s[i-1]) ){
                //先看前一位是否是数字
                if(!isdigit(s[i-2])){
                    //如果前一位不是数字而是'*',分为两种情况:
                    //1.当前数字小于等于6,那么前一位与当前位可以拼接为两种两位数(前一位取1或者2),但是如果当前位是'0'其只能选择与前一位拼接 
                    //2.当前位大于6,如果前一位要与其拼接且小于等于26的话,前一位只能取1
                    if( (s[i-1]  - '0') <= 6 ) {
                        if(s[i-1] == '0') dp[i] = dp[i-2]*2;   
                        else dp[i] = dp[i-1] + dp[i-2]*2;
                    }else dp[i] = dp[i-1] + dp[i-2];

                }else{
                    if(s[i-2] == '0'){ 
                        //如果前一位是0,则当前数字无法与前一位拼接;如果当前位也是0则直接返回0
                        if(s[i-1] == '0') return 0;
                        dp[i] = dp[i-1];
                    }else{
                        //如果不为0则观察当前位与前一位拼接而成的两位数是否大于26：
                        //1.如果小于26,就要加上前一位与当前位拼接的情况
                        //2.否则相当于之前的情况
                        int number = (s[i-2] - '0') * 10 + (s[i-1] - '0');
                        
                        if(s[i-1] == '0'){
                            //如果当前位为0,其只能选择与前一位拼接
                            //但是如果拼接结果超出范围,只能返回0
                            if(number > 26) return 0;              
                            dp[i] = dp[i-2];        
                        }else{
                            if(number <= 26) dp[i] = dp[i-1] + dp[i-2];
                            else  dp[i] = dp[i-1];
                        }
                        
                    }
      
                }
            }else{ 
                //如果当前位不是数字,就看前一位是否是数字
                //不与前一位拼接,本身'*'可以取9种情况,所以至少为之前的情况*9;
                dp[i] = dp[i-1]*9;
                
                if(isdigit(s[i-2])){
                    
                    //如果前一位是数字是1,那么当前位可以与前一位拼接成11-19共计9种情况
                    //如果前一位数字是2,那么当前位可以与前一位拼接成21-26共6种情况
                    //其余情况皆无法拼接
                    if(s[i-2] == '1') dp[i] +=  dp[i-2] * 9;
                    else if(s[i-2] == '2') dp[i] += dp[i-2] * 6;
                    
                }else{
                    //如果与前一位拼接,两个*可以拼接出11-26种除了20共15种情况
                    dp[i] += dp[i-2] * 15;   
                }
            }
            
            dp[i] = (dp[i] + 1000000007)%1000000007;
            
        }
        
        return dp[n];
        
        
    }
};
